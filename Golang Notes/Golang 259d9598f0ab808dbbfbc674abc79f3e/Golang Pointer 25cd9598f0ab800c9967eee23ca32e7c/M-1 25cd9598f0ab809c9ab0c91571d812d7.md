# M-1

# **Golang Pointers**

![Soulaimaneyh](https://miro.medium.com/v2/resize:fill:64:64/1*sfyEtYZw2JvWW9PqX4w-eg.jpeg)

[Soulaimaneyh](https://medium.com/@soulaimaneyh?source=post_page---byline--40e9e242a96b---------------------------------------)

Follow

3 min read

·

Jun 25, 2023

3

Press enter or click to view image in full size

![Golang Pointers](https://miro.medium.com/v2/resize:fit:700/1*V2rZSRmwm93AStp8GMYfyg.png)

Golang Pointers

A pointer in Go is a variable that **holds the memory address of another variable**. It allows you to reference and manipulate the original variable directly, enabling efficient **memory management and data manipulation** without copying large data structures.

in Go, a pointer is a distinct data type. It is defined by the type it points to, such as; `*int`, `*string`, or `*struct`

Let’s consider an expl to illustrate how pointers work in Go:

**Exp pointer of type *string;**

```
package main

import "fmt"

func updateName(name *string) {
 *name = "xx"
}

func main() {
 name := "x"

 updateName(&name)

 fmt.Println(name)
}

// Output is xx
```

**Exp pointer of type *int;**

```
package main

import "fmt"

func main() {
    x := 10
    fmt.Println("Value of x:", x)
    fmt.Println("Memory address of x:", &x)

    var ptr *int
    ptr = &x
    fmt.Println("Value stored in ptr:", ptr)
    fmt.Println("Dereferenced value of ptr:", *ptr)

    *ptr = 20
    fmt.Println("Updated value of x:", x)
}

output:
Value of x: 10
Memory address of x: 0xc00001
Value stored in ptr: 0xc00001
Dereferenced value of ptr: 10
Updated value of x: 20
```

In this example, we declare a variable `x` and assign it the value `10`. We then print **the value of `x`** and **its memory address using the `&` operator**.

Next, we declare a pointer variable `ptr` of type `*int`. We assign the memory address of `x` to `ptr` using the `&` operator. We then print the value stored in `ptr` and the dereferenced value of `ptr` using the `*` operator.

The **`*` operator is used to de-reference a pointer,** which means accessing the value stored at the memory address pointed to by the pointer. In this case, `*ptr` gives us the value of `x`.

Finally, we update the value of `x` **by assigning `20` to `*ptr`**. Since `ptr` points to the memory address of `x`, **updating `*ptr` is equivalent to updating `x`**.

Now, let’s visualize the memory layout for the variables `x` and `ptr`:

```
Memory:
+-------+     +----------+
|   x   | --> |    10    |
+-------+     +----------+
|  ptr  | --> | 0xc00001 |
+-------+     +----------+
```

In the memory diagram above, `x` is allocated memory to store the value `10`, and `ptr` is allocated memory to store the memory address of `x` (represented as `0xc00001`).

By using the `*` operator to dereference `ptr`, we can access and modify the value stored in `x` indirectly.

We will explore expl that showcases the application of pointers in Go, specifically **with a struct** that represents user data:

```
package main

import "fmt"

type User struct {
 Name  string
 Email string
}

func updateUser(user *User, name, email string) {
 user.Name = name
 user.Email = email
}

func main() {
 user := User{
  Name:  "John Doe",
  Email: "john@doe.com",
 }

 fmt.Println("xBefore:")
 fmt.Println("Name:", user.Name)
 fmt.Println("Email:", user.Email)

 updateUser(&user, "Jane Smith", "jane@smith.com")

 fmt.Println("\nxAfter:")
 fmt.Println("Name:", user.Name)
 fmt.Println("Email:", user.Email)
}
```

In this example, we define a `User` struct with `Name` and `Email` fields representing user data.

The `updateUser` function takes a **pointer to a `User` (`*User`) as its first parameter**, along with the new `name` and `email` values. Inside the function, we modify the `Name` and `Email` fields of **the original`User` struct** using the pointer.

By using pointers, we can pass the memory address of the `user` struct to the `updateUser` function, allowing it to modify the original data without making a copy. **This approach is efficient when working with large structures** and enables us to **work directly with the object's memory location**.

Passing a large structure by pointer in Go

```
package main

import "fmt"

// Define a large struct
type LargeStructType struct {
 Data [1000]int
}

// update function
func modifyStruct(ls *LargeStructType) {
 ls.Data[0] = 999 // Modify the original structure's data
}

func main() {
 ls := LargeStructType{}
 fmt.Println("xBefore:", ls.Data[0]) // Initial value

 modifyStruct(&ls)                  // Pass by pointer to modify directly
 fmt.Println("xAfter:", ls.Data[0]) // Shows modified value
}
```

- By passing `LargeStructType` (a pointer) to `modifyStruct`, we avoid copying all the data, making it more memory efficient.
- In Go, the `Data` array elements are zero-initialized automatically

> Read more: Explaining Passing by value on Golang
> 

# **In summary**

Pointers in Go allow you to indirectly **access and manipulate the value of a variable** by storing its memory address. **They are particularly useful when you want to modify the original value** of a variable without making a copy, or when you want to pass large structures efficiently to functions.