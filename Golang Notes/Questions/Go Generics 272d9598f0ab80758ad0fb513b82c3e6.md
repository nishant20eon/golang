# Go Generics

## üîπ 10 Real-World Practice Questions on Go Generics

### 1. **Generic Swap Function**

- Write a generic function `Swap[T any](a, b T) (T, T)` that swaps two values of any type.
- Test with `int`, `string`, and `float64`.

---

### 2. **Generic Sum of Numbers**

- Write a generic function `Sum[T int | float64](numbers []T) T` to calculate the sum of any numeric slice.
- Test with `[]int` and `[]float64`.

---

### 3. **Generic Max Function**

- Write a generic function `Max[T int | float64](values []T) T` to find the maximum value in a slice.

---

### 4. **Generic Filter Function**

- Write a generic function `Filter[T any](slice []T, predicate func(T) bool) []T` to filter elements based on a condition.
- Example: filter even numbers from `[]int`.

---

### 5. **Generic Map Function**

- Write a generic function `Map[T any, R any](slice []T, fn func(T) R) []R` to transform elements.
- Example: convert `[]int` to `[]string` with string representation.

---

### 6. **Generic Stack Type**

- Implement a generic `Stack[T any]` type with `Push`, `Pop`, and `Peek` methods.
- Test with `int` and `string` stack.

---

### 7. **Generic Pair Type**

- Implement a generic `Pair[T, U any]` type holding two values of possibly different types.
- Create a pair for `<string, int>` and `<float64, string>`.

---

### 8. **Generic Find Function**

- Write a generic function `Find[T comparable](slice []T, value T) (int, bool)` to find the index of a value in a slice.

---

### 9. **Generic Reduce Function**

- Write a generic function `Reduce[T any, R any](slice []T, initial R, fn func(R, T) R) R` to reduce a slice to a single value.
- Example: concatenate `[]string` into a single string.

---

### üîü **Generic Queue Type**

- Implement a generic `Queue[T any]` type with `Enqueue`, `Dequeue`, and `IsEmpty` methods.
- Test with `int` and `string` queue.

## 1Ô∏è‚É£ Generic Swap Function

```go
package main

import "fmt"

func Swap[T any](a, b T) (T, T) {
    return b, a
}

func main() {
    x, y := 10, 20
    x, y = Swap(x, y)
    fmt.Println("Swapped ints:", x, y)

    s1, s2 := "Hello", "World"
    s1, s2 = Swap(s1, s2)
    fmt.Println("Swapped strings:", s1, s2)

    f1, f2 := 1.5, 2.5
    f1, f2 = Swap(f1, f2)
    fmt.Println("Swapped floats:", f1, f2)
}

```

---

## 2Ô∏è‚É£ Generic Sum of Numbers

```go
package main

import "fmt"

func Sum[T int | float64](numbers []T) T {
    var total T
    for _, n := range numbers {
        total += n
    }
    return total
}

func main() {
    ints := []int{1, 2, 3, 4}
    floats := []float64{1.1, 2.2, 3.3}

    fmt.Println("Sum of ints:", Sum(ints))
    fmt.Println("Sum of floats:", Sum(floats))
}

```

---

## 3Ô∏è‚É£ Generic Max Function

```go
package main

import "fmt"

func Max[T int | float64](values []T) T {
    max := values[0]
    for _, v := range values {
        if v > max {
            max = v
        }
    }
    return max
}

func main() {
    nums := []int{10, 20, 5, 30}
    fmt.Println("Max:", Max(nums))

    flts := []float64{1.5, 3.7, 2.2}
    fmt.Println("Max float:", Max(flts))
}

```

---

## 4Ô∏è‚É£ Generic Filter Function

```go
package main

import "fmt"

func Filter[T any](slice []T, predicate func(T) bool) []T {
    var result []T
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

func main() {
    nums := []int{1, 2, 3, 4, 5, 6}
    even := Filter(nums, func(n int) bool { return n%2 == 0 })
    fmt.Println("Even numbers:", even)
}

```

---

## 5Ô∏è‚É£ Generic Map Function

```go
package main

import "fmt"

func Map[T any, R any](slice []T, fn func(T) R) []R {
    result := make([]R, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

func main() {
    nums := []int{1, 2, 3}
    strs := Map(nums, func(n int) string { return fmt.Sprintf("Number %d", n) })
    fmt.Println(strs)
}

```

---

## 6Ô∏è‚É£ Generic Stack Type

```go
package main

import "fmt"

type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(item T) {
    s.items = append(s.items, item)
}

func (s *Stack[T]) Pop() T {
    item := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return item
}

func (s *Stack[T]) Peek() T {
    return s.items[len(s.items)-1]
}

func main() {
    s := Stack[int]{}
    s.Push(10)
    s.Push(20)
    fmt.Println("Peek:", s.Peek())
    fmt.Println("Pop:", s.Pop())
    fmt.Println("Pop:", s.Pop())

    s2 := Stack[string]{}
    s2.Push("Hello")
    s2.Push("World")
    fmt.Println("Pop:", s2.Pop())
}

```

---

## 7Ô∏è‚É£ Generic Pair Type

```go
package main

import "fmt"

type Pair[T, U any] struct {
    First  T
    Second U
}

func main() {
    p1 := Pair[string, int]{"Alice", 25}
    p2 := Pair[float64, string]{3.14, "Pi"}

    fmt.Println(p1)
    fmt.Println(p2)
}

```

---

## 8Ô∏è‚É£ Generic Find Function

```go
package main

import "fmt"

func Find[T comparable](slice []T, value T) (int, bool) {
    for i, v := range slice {
        if v == value {
            return i, true
        }
    }
    return -1, false
}

func main() {
    nums := []int{10, 20, 30}
    index, found := Find(nums, 20)
    fmt.Println("Index:", index, "Found:", found)
}

```

---

## 9Ô∏è‚É£ Generic Reduce Function

```go
package main

import "fmt"

func Reduce[T any, R any](slice []T, initial R, fn func(R, T) R) R {
    result := initial
    for _, v := range slice {
        result = fn(result, v)
    }
    return result
}

func main() {
    words := []string{"Go", "Generics", "are", "Powerful"}
    sentence := Reduce(words, "", func(acc string, w string) string {
        if acc == "" {
            return w
        }
        return acc + " " + w
    })
    fmt.Println(sentence)
}

```

---

## üîü Generic Queue Type

```go
package main

import "fmt"

type Queue[T any] struct {
    items []T
}

func (q *Queue[T]) Enqueue(item T) {
    q.items = append(q.items, item)
}

func (q *Queue[T]) Dequeue() T {
    item := q.items[0]
    q.items = q.items[1:]
    return item
}

func (q *Queue[T]) IsEmpty() bool {
    return len(q.items) == 0
}

func main() {
    q := Queue[int]{}
    q.Enqueue(1)
    q.Enqueue(2)
    fmt.Println("Dequeue:", q.Dequeue())
    fmt.Println("Is empty?", q.IsEmpty())
}

```